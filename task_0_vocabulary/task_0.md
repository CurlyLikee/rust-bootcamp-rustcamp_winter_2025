task_0
========================================

## What memory model Rust has?

Раст використовує модель володіння пам'ятю. В ній використовуются такі принципи як ownership(володіння) який має власника, який слідкує щоб об'єкт не виходив за межі
видимості, а якщо виходить то об'єкт видадяєтся, щоб не було накопичення зайвої пам'яті і borrowing (запозичення) який є або immutable (читає дані але не може записувати і
змінювати їх)

```rust
fn main() {
    let s = String::from("Hello");
    let b1 = &s;
    let b2 = &s;
    println!("{}", b1);
    println!("{}", b2);
}
```

або mutable (може читати записувати і змінювати дані).

```rust
fn main() {
    let mut s = String::from("Hello");
    let b1 = &mut s;
    b1.push_str(", world!");
    println!("{}", b1);
}
```

Таким чином за допомогою цієї моделі уникаються можливі витоки пам'яті і не збирається зайве сміття.

## Is it single-threaded or multi-threaded?

Раст за замовчуванням є однопоточний, але підтримує багатопоточність

## Is it synchronous or asynchronous?

Підтримується так і асинхроне(async) так і синхроне(await) виконання.

Асинхроне робить щось в фоновому режимі і не заморожує решту коду в свою чергу як синхроне чекає поки завершится одна операція потім йде на іншу операцію і заморожує тим самим
виконання решти коду

## What are the memory layouts of Box and Vector?

Box розумний покажчик, який дозволяє зберігати дані в купі та керувати їх пам'яттю.
Vector це динамічний масив, який може змінювати свій розмір в процесі роботи програми.

## What are a heap and a stack?

Heap це область пам'яті, яка використовується для зберігання даних, які повинні жити довше, ніж функція що їх створила. Управління купою відбувається вручну, програміст
сам виділяє та звільняє пам'ять.

Плюси:
• Гнучкість: можна виділити скільки завгодно пам'яті (у межах доступної оперативної пам'яті).
• Використовується для великих даних або об'єктів, які повинні жити довго (наприклад поки програма працює).

Мінуси:
• Повільніше, ніж стек: виділення та звільнення пам'яті займає більше часу.
• Можливі помилки: якщо забути звільнити пам'ять, витік пам'яті.

Stack це область пам'яті, яка використовується для зберігання даних тимчасового характеру (наприклад змінні всередині функцій). Коли main закінчується, все що лежить у
стеку автоматично очищується.

Плюси:
• Швидкий доступ: виділення пам'яті та її звільнення відбувається за частки секунди.
• Керується автоматично: програмісту не потрібно явно очищати стек.

Мінуси:
• Обмежений розмір: стек має фіксовану максимальну ємність (зазвичай кілька мегабайт).
• Підходить лише для тимчасових даних.

## Where, but on heap and stack data could live in RAM?

Крім стека та купи, дані можуть зберігатися в інших частинах пам'яті, таких як:
• Глобальна/статична пам'ять: змінні, оголошені з static або const, зберігаються у глобальній області пам'яті.
• Регістр процесора: це пам'ять з дуже швидким доступом, що використовується для зберігання тимчасових значень у процесі обчислень.
• Пам'ять на пристрої: у випадку з системами що вбудовуються, дані можуть бути розміщені в спеціальній пам'яті, наприклад на графічному процесорі.

## What runtime Rust has? Does it use a GC (garbage collector)?

Раст має мінімальний runtime, який використовується тільки для деяких базових операцій, таких як багатозадачність (за допомогою async/await), робота з потоками та
керування пам'яттю. На відміну від інших мов з повноцінним збирачем сміття, весь основний контроль (наприклад управління пам'яттю) здійснюється на етапі компіляції через
систему володіння та запозичення, тому garbage collector не використовується.

## What is special about slice?

Slice це посилання на частину існуючого масиву, вектора чи рядка, який вказує на частину вже існуючих даних. Тому зміни в слайсі можуть вплинути на оригінальні дані
(якщо змінюється слайс).

## What is the layout of Rust standard data types?

Стандартні типи даних мають різне розташування пам'яті залежно від їх типу. Прості типи, такі як i32, займають фіксовану кількість пам'яті, наприклад 4 байти. Посилання
та розумні покажчики, такі як Box<T> займають покажчик (8 байт на 64-бітних системах) і можуть містити додаткові дані, як розмір або ємність. Масиви та вектори мають дані,
розташовані в пам'яті послідовно, але для векторів додаються метадані для керування їх розміром та ємністю. Структури та перерахування можуть мати специфічне розташування в
залежності від їх полів.

## Difference between fat and thin pointers?

Thin pointer – це покажчик, який зберігає лише адресу даних (зберігає лише одну адресу).
Fat pointer – це покажчик, який зберігає адресу та додаткову інформацію (наприклад довжину даних).

## Why does Rust have &str and String types? How do they differ?

&str — це посилання на рядок, який вже існує в пам'яті.
String — це рядок, що змінюється, вона зберігає дані в купі і може бути змінена (додавання, видалення символів).

## When should you use them?

Використовувати &str, коли потрібно просто послатися на рядок, який вже існує і не вимагає змін.
String, якщо потрібно динамічно змінювати рядок, додавати щось до нього або працювати з введенням користувача.

## Why str slice coexists with slice?

&str — спеціалізований зріз рядка (або зріз символів). Він успадковує особливості зрізів у Rust, але працює тільки з даними рядків.
slice – це загальний зріз даних будь-якого типу. Це може бути зріз масиву, зріз вектора або рядок.

## What is the difference between String and Vec?

String – це структура даних, призначена для зберігання рядків. Вона працює із символами та містить UTF-8 кодування.
Vec – це структура даних для зберігання довільних типів, наприклад чисел або об'єктів. Це просто динамічний масив, який може зберігати елементи будь-якого типу, і він
може розширюватися в міру необхідності.

## What static typing means? What are the benefits of using it?

Static typing це система, тип якої визначено етапі компіляції, неспроможна змінюватися під час виконання програми.

```rust
fn main() {
    let x: i32 = 5;  // статична типізація
    x = "hello";  // помилка компіляції: невідповідність типів
}
```

Переваги статичної типізації:
• Безпека: багато помилок виявляються до запуску програми.
• Продуктивність: компілятор оптимізує код, знаючи типи даних.
• Самодокументованість: легко зрозуміти, які типи даних використовуються.

## Weak vs strong typing?

Rust - це строго типізована мова, де програміст повинен явно вказувати перетворення типів, що запобігає безлічі помилок і робить код надійним
переваги:
• типи даних суворо контролюються
• жодних неявних перетворень між типами
• усі помилки типів виявляються етапі компіляції

```rust
fn main() {
    let x = 10;         // тип i32
    let y = "20";       // тип &str
    let z = x + y;   // помилка: rust не перетворює рядок на число автоматично
}
```

## Чому Rust не слабка типізація (Weak Typing)?

Rust не дозволяє автоматичних перетворень. Наприклад, рядок не можна скласти з числом без явного перетворення. Це робить код більш безпечним та передбачуваним.

```rust
fn main() {
    let x: f32 = 10.5;  // тип f32
    let y: i32 = 3;     // тип i32
    let z = x + y;   // помилка: не можна змішувати типи f32 та i32.
}
```

## Implicit vs explicit typing?

Rust підтримує неявну типізацію, але там де компілятор може однозначно вивести тип даних. Використовується ключове слово let і тип змінної визначається автоматично. Це
робить код лаконічним, але не жертвує безпекою.

```rust
fn main() {
    let x = 10;       // компілятор визначає тип x як i32
    let y = 3.14;     // компілятор визначає тип y як f64
}
```

Явна типізація використовується, коли вказується тип змінної. 
• корисно для покращення читаності або у разі потреби уточнити тип.
• раст вимагає явної вказівки типу у складних випадках.

```rust
fn main() {
    let x: i64 = 100; // явно вказуємо тип як i64
    let y: f32 = 3.14; 
}
```

## Коли використовувати Implicit та Explicit Typing?

Implicit Typing (Неявна):
Коли тип очевидний і потребує пояснень (наприклад, let x = 10;).

Explicit Typing (Явна):
Коли важливо уточнити тип ясності чи логіки (наприклад, let x: u32 = 10;).

## What are generics and parametric polymorphism? 

Generic - це спосіб створювати функції чи структури, які працюють із будь-якими типами даних де використовується параметр типу. Це дозволяє писати універсальний код,
який працюватиме з різними типами, але зберігає безпеку типів.

Parametric polymorphism - одна функція або структура може працювати з різними типами даних завдяки параметризації (використання параметрів типу).

## Які проблеми вирішують generics та parametric polymorphism?

• Дублювання коду: замість того, щоб писати те саме для різних типів даних (наприклад, для цілих чисел і чисел з плаваючою точкою), можна написати одну функцію або
структуру, яка буде працювати з будь-якими типами.
• Гнучкість: можна створювати універсальні рішення, які підходять для різних типів даних, не обмежуючи себе конкретними типами.
• Типова безпека: компілятор перевіряє типи на етапі компіляції, запобігаючи помилкам типів у коді, навіть якщо використовувати універсальні конструкції.

## What are nominative typing and structural typing? What is the difference?

Номінативне типування — два типи вважаються різними, якщо їхні імена різні, навіть якщо їхня структура однакова. Наприклад, дві структури з однаковими полями, але
різними іменами будуть різними типами.

```rust
struct A { x: i32 }
struct B { x: i32 }
let a = A { x: 5 };
let b = B { x: 10 };
// помилка: A і B — різні типи, незважаючи на однакову структуру
```

Structural Typing: у раст немає структурного типування. У мовах з цим типуванням два типи вважаються однаковими, якщо вони однакова структура, навіть якщо їх імена різні.

Головна відмінність:
• Номінативне типування залежить від імені типу.
• Структурне типування залежить від структури типу (не використовується в Rust).

## What are traits? How are they used?

Трейти - це спосіб описати поведінку, яка має реалізувати тип.

```rust
trait Speak {
    fn speak(&self);
}

struct Dog;
impl Speak for Dog {
    fn speak(&self) {
        println!("Woof!");
    }
}
```

##  How do they compare to interfaces? 

У трейт можна додавати методи з реалізацією за умовчанням. Їх можна реалізувати для типів, які не створювалися власноруч.

## What are auto trait and blanket impl? 

Auto Traits застосовуються автоматично (наприклад Send та Sync).
Marker Traits просто позначають властивості типу без методів.
Blanket Impl дозволяє реалізувати трейт одночасно для всіх відповідних типів (наприклад будь-який тип який вміє Display можна перетворити на String).

```rust
impl<T: Display> ToString for T {
    fn to_string(&self) -> String {
        format!("{}", self)
    }
}
```

## Uncovered type?

Uncovered type – це тип, для якого немає конкретної реалізації трейту у поточному контексті. В основному це зустрічається, коли використовуються узагальнені типи
(generics) або є обробка типів з обмеженнями, але компілятор не може знайти реалізацію потрібного трейту для певного типу.

```rust
trait Speak {
    fn speak(&self);
}

struct Dog;
struct Cat;
impl Speak for Dog {
    fn speak(&self) {
        println!("Woof!");
    }
}

// немає реалізації для Cat, значить це uncovered type
fn make_speak<T: Speak>(item: T) {
    item.speak();
}

fn main() {
    let dog = Dog;
    make_speak(dog);
    let cat = Cat;
    make_speak(cat); // помилка: тип `Cat` не реалізує `Speak`
}
```

## What are marker traits?

Маркерні трейти — це трейти без методів, які використовуються для маркування типів та передачі компілятору або програмі додаткової інформації про типи. Вони не додають
функціональності, а просто вказують, що тип має певну властивість.

Наприклад:
• Send та Sync — маркерні трейти для безпечного використання типів у багатозадачності.
• Drop — маркерний трейт, який вказує на те, що тип повинен виконати дії при знищенні (наприклад звільнити ресурси).
• Користувальницькі маркерні трейти можуть використовуватися для специфічних завдань, наприклад для позначення типів, які можна кешувати.

## What are static and dynamic dispatches?

Статична диспетчеризація – це коли компілятор вирішує, який метод чи функція має бути викликана на етапі компіляції. Тобто компілятор наперед знає, який код потрібно
виконати.

```rust
fn add<T>(a: T, b: T) -> T {
    a + b
}
```

Динамічна диспетчеризація — коли вибір методу відбувається під час виконання програми, а не на етапі компіляції. Це зазвичай пов'язано з використанням трейтів, особливо,
коли вони мають методи без явної реалізації (наприклад з поліморфізмом).

## Which should you use, and when?

Статична диспетчеризація – краще для продуктивності і коли типи відомі на етапі компіляції.
Динамічна диспетчеризація – краще, коли хочеш гнучкість і можеш працювати з типами, яких не знаєш заздалегідь.

## What is monomorphization?

Монорфізація — це процес, у якому компілятор Rust генерує конкретний код кожному за типу, з яким працює узагальнений код. Наприклад, якщо пишеться функція з узагальненим
типом T, компілятор створює окрему версію цієї функції для кожного конкретного типу, з яким вона буде використовуватися.

```rust
fn add<T>(a: T, b: T) -> T {
    a + b
}
let int_sum = add(5, 10); // компілятор створює функцію типу i32
let float_sum = add(1.2, 3.4); // компілятор створює функцію типу f64
```

## What are a crate, a module, a workspace and a package in Rust? How do they differ?

Crate - це мінімальна одиниця компіляції в Rust. Кожний проект у Rust починається з crate. Це може бути як бібліотека, так і можлива програма. Кожен crate компілюється в
одну мету (або бінарник або бібліотеку), і він може містити декілька модулів.

Модуль - це спосіб організації коду всередині crate. Модулі допомагають розбивати код на логічні частини, підвищуючи читання та зручність роботи. Модуль може бути як в
одному файлі, так і в декількох файлах або навіть під папках. Модуль оголошується ключовим словом mod де кожен модуль має свій простір імен, що дозволяє уникнути конфліктів між
іменами.

```rust
mod my_module {
    pub fn say_hello() {
        println!("Hello from my_module!");
    }
}

fn main() {
    my_module::say_hello();
}
```

Пакет - це ширший контейнер, який може містити кілька crates. Пакет може включати один основний crate (наприклад бібліотеку або бінарний проект) і можливо інші допоміжні crates.
Package завжди містить файл Cargo.toml, який описує проект. Package може містити один або кілька crates (наприклад один бінарний crate і один або кілька бібліотечних).

Workspace – це набір пакетів, які знаходяться в одному проекті та можуть ділити загальну конфігурацію та залежності. Workspaces допомагають керувати кількома пов'язаними
пакетами та спрощують керування залежностями між ними. У workspace може бути кілька пакетів які дозволяють легко працювати з кількома пов'язаними проектами, прискорюючи
компіляцію та покращуючи організацію коду.

## How are they used?

Crate використовується завжди, коли створюєш проект. Це або бібліотека, або програма, що можна здійснити.
Module – використовуєш для організації коду всередині crate. Наприклад, якщо маєш багато функцій, ти можеш розділити їх за модулями.
Package - коли ти працюєш з проектом, який може включати кілька crates (наприклад один основний і кілька допоміжних).
Workspace — якщо потрібно працювати з кількома пов'язаними пакетами і ділити їх залежності.

## What is cloning?

Сloning - це процес створення глибокої копії об'єкта. Коли ти клонуєш об'єкт, створюється новий об'єкт, який має ті ж дані, що й вихідний, але на відміну від копіювання,
клонований об'єкт має незалежну пам'ять і зміни в одному об'єкті не торкнуться іншого.

```rust
let s1 = String::from("Hello");
let s2 = s1.clone();
```

## What is copying?

Сopying – це створення поверхневої копії об'єкта. Це працює для типів, які продають трейт Copy. На відміну від клонування, копіювання не потребує виділення нової пам'яті
або створення глибоких копій. Типи, що реалізують Copy, мають такий простий механізм копіювання.

```rust
let x = 42;
let y = x; // копіюємо значення, оскільки i32 реалізує Copy
```

## How do they compare?

Сloning — це створення глибокої копії, що потребує виділення нової пам'яті. Використовується для типів, які не можуть бути скопійовані за допомогою бітової копії
(наприклад рядки або вектори).
Сopying – це створення поверхневої копії для типів, які продають трейт Copy. Це легковажна операція, оскільки не потрібно виділення нової пам'яті для зберігання даних.

## Коли використовувати?

Сopying, коли працюєш із типами, які реалізують трейт Copy, наприклад, з примітивами чи невеликими типами.
Сloning, коли потрібно створити копію об'єкта, який не підтримує Copy, або коли об'єкт вимагає виділення нової пам'яті (наприклад рядки, вектори і т. д.).

## What is trait Drop for?

Drop — це трейт, який визначає, що має відбуватися з об'єктом, коли він виходить із області видимості. Це зазвичай використовується для звільнення ресурсів, таких як
пам'ять, файли, з'єднання тощо. буд. Він надає метод drop, який викликається автоматично, коли об'єкт знищується.

```rust
struct MyStruct {
    name: String,
}

impl Drop for MyStruct {
    fn drop(&mut self) {
        println!("Object with name {} is being dropped!", self.name);
    }
}

fn main() {
    let obj = MyStruct { name: String::from("Rust") };
    // Коли `obj` виходить з області видимості, викликається метод `drop`
}
```

## What is special about this trait?

Трейт Drop використовується для автоматичного звільнення ресурсів у разі знищення об'єкта. Коли об'єкт виходить із області видимості, якщо він реалізує Drop, Rust
викликає метод drop для цього об'єкта. Це дозволяє уникати витоків пам'яті та інших ресурсів, тому що Rust управляє пам'яттю та автоматичним звільненням ресурсів через систему
володіння та запозичень.

## What is immutability?

Immutability — це властивість даних або об'єктів, за яких їх стан не може бути змінений після того, як вони були створені. У Rust за замовчуванням змінні є незмінними
(immutable), якщо явно не вказано протилежне коли оголошуєш змінну як незмінну (за допомогою ключового слова let), ти не можеш змінити її значення надалі.

```rust
let x = 5;
// x = 6; // помилка: спроба змінити незмінну змінну
```

## What is the benefit of using it?

Використання незмінності у коді дає кілька переваг:

• Безпека та передбачуваність: Коли об'єкт або змінна незмінні, ти знаєш, що їх значення не зміняться в процесі роботи програми. Це спрощує налагодження та робить код
більш надійним.
• Паралелізм: У багатозадачних та багатопотокових додатках використання незмінних даних дозволяє безпечно працювати з ними з різних потоків без необхідності
синхронізації (оскільки дані не змінюються, виключається гонка даних).
• Спрощення логіки: Зміни станів можуть спричинити складні помилки. Використання незмінності зменшує кількість несподіваної поведінки, роблячи код простіше для розуміння
та тестування.

## What is the difference between immutability and const?

Immutability (незмінність) відноситься до змінних, які не можна змінити після їх створення, але вони можуть бути обчислені або ініціалізовані динамічно

```rust
let x = 5; // x може бути змінено, але воно обчислюється у процесі виконання
```

Сonst – це константа. Константи - це значення, які не тільки незмінні, а й обчислюються на етапі компіляції, і їх значення має бути відомим на момент компіляції

```rust
const Y: i32 = 10; // Y - це константа, яка не може бути змінена
```

Відмінність:
Immutability стосується змінних, чиї значення не можна змінити під час виконання, але їх можна обчислювати динамічно
Сonst - це завжди константи з фіксованим значенням, яке відоме на момент компіляції

## What are move semantics?

Move Semantics - це концепція в Rust, при якій дані не копіюються, а переміщуються з однієї змінної до іншої. Це дозволяє уникнути дорогих операцій копіювання та
покращити продуктивність, особливо для великих об'єктів (наприклад векторів чи рядків). Коли "переміщаєш" значення, воно втрачає свій початковий зв'язок із джерелом, і ти
більше не можеш використовувати вихідну змінну, але нова змінна тепер володіє цими даними.

```rust
let s1 = String::from("Hello");
let s2 = s1; // переміщаємо володіння з s1 до s2
println!("{}", s1); // Помилка! s1 більше не володіє даними
println!("{}", s2); // "Hello"
```

## What are borrowing rules?

Borrowing - це система запозичення в Rust, яка дозволяє одному об'єкту тимчасово запозичувати доступ до даних іншого об'єкта. При цьому оригінальний об'єкт зберігає дані.

Існує два типи запозичення:
Immutable borrowing (незмінне запозичення) - коли ми даємо посилання на дані, але не дозволяємо змінювати їх.
Mutable borrowing (змінне запозичення) - коли ми даємо посилання на дані і дозволяємо їх змінювати.

Правила запозичення:
Можна мати кілька незмінних посилань на дані, але не можна мати посилання, що змінюється одночасно.
Можна мати одне змінне посилання, але не можна мати одночасно незмінні або інші посилання, що змінюються.

```rust
let mut x = 5;
let y = & x; // Постійне посилання на x
let z = & x; // Ще одне незмінне посилання
let w = & mut x; // Помилка: не можна створити змінне посилання, коли є незмінні
```

##  What is the benefit of using them?

• Безпека пам'яті: Ці концепції допомагають уникнути помилок, пов'язаних із володінням та доступом до пам'яті. Наприклад, переміщення даних гарантує, що об'єкт не
використовуватиметься після того, як його власником стала інша змінна.
• Підвищення продуктивності: Переміщення даних замість копіювання знижує накладні витрати, особливо для великих об'єктів. Запозичення дозволяє уникнути копіювання даних
та зробити код ефективнішим.
• Запобігання гонкам даних: Використання правил запозичення запобігає можливості одночасного доступу до даних з кількома потоками (при цьому дані можуть бути
змінюваними, або незмінними, але не одночасно).
• Спрощення багатозадачності: Завдяки системі запозичення Rust дозволяє безпечно передавати дані між різними частинами програми і потоками, не побоюючись за порушення
безпеки.

## What is RAII?

RAII (Resource Acquisition Is Initialization) – це концепція управління ресурсами, яка широко використовується в C++ та інших мовах, включаючи Rust. Вона полягає в тому,
що виділення ресурсу (наприклад, пам'яті, файлу, з'єднання тощо) прив'язується до життєвого циклу об'єкта. Коли об'єкт створюється, ресурс ініціалізується, а коли об'єкт
виходить із області видимості, ресурс автоматично звільняється.

## How is it implemented in Rust?

У Rust RAII вбудовано на рівні мови через такі механізми:

• Ініціалізація під час створення об'єкта: ресурси, такі як пам'ять або файлові дескриптори, виділяються та прив'язуються до структури (наприклад, File або Vec).
• Автоматичне звільнення ресурсів за допомогою деструкторів: у Rust є концепція дропа (Drop trait). Коли об'єкт виходить із області видимості (тобто більше не
використовується), викликається метод drop для звільнення ресурсів. Наприклад, структура File закриває файл, структура Vec звільняє пам'ять.
• Система володіння: Rust гарантує, що ресурси мають лише одного власника у будь-який момент часу. Це робить керування пам'яттю безпечним і запобігає витоку. Коли
власник об'єкта виходить із області видимості, ресурс звільняється автоматично.

```rust
use std::fs::File;
use std::io::{self, Write};

fn main() -> io::Result<()> {
    {
        let mut file = File::create("example.txt")?; // ресурс (файл) виділено
        writeln!(file, "Hello, RAII!")?;            // робота з файлом
    } // коли файл виходить з області видимості, він автоматично закривається
    Ok(())
}
```

## What is the benefit of using it?

• Безпека ресурсів: немає необхідності вручну звільняти ресурси (як C). Це допомагає уникнути витоків пам'яті та помилок, пов'язаних із подвійним звільненням.
• Ясність коду: управління ресурсами стає прозорим, оскільки пов'язані з життєвим циклом об'єкта.
• Захист від винятків: у Rust обробка помилок через Result або паніки не порушує роботу RAII. Навіть у разі паніки деструктори (drop) все одно викликаються.
• Поліпшення читаності та підтримки коду: оскільки ресурси звільняються автоматично, програмісти можуть зосередитись на бізнес-логіці, а не на низькорівневих деталях.

## What are lifetimes? 
Lifetimes (часи життя) - це анотації в Rust, які показують, як довго посилання залишається дійсним. Компілятор використовує їх для перевірки того, що посилання не
переживає дані, на які вона вказує. Це важлива частина системи володіння, яка допомагає Rust забезпечувати безпеку пам'яті без збирача сміття.

## Which problems do they solve?

• Проблема висячих посилань: висяче посилання виникає, коли посилання вказує на дані, які вже видалено. Lifetimes гарантують, що посилання дійсні лише до того часу, поки
існують дані.

```rust
fn dangling_reference() -> &i32 {
    let value = 42; // value створюється на стеку
    &value // повертаємо посилання на value
} // value видаляється, посилання стає недійсним
```

• Конфліктуючі часи життя: коли різні посилання на один і той же об'єкт використовуються в одному контексті, життячасів допомагають визначити, яке посилання "головніше",
щоб уникнути помилок.
• Безпека при запозиченні: ifetimes дозволяють гарантувати, що посилання, що змінюється і незмінна, не використовуються одночасно, що запобігає стану гонок та інші
помилки.

## Which benefits do they provide?

• Безпека пам'яті: Lifetimes запобігають доступу до неіснуючих даних, зменшуючи ймовірність помилок (наприклад, сегфолтів).
• Немає витоків пам'яті: Rust автоматично стежить за часом життя об'єктів, звільняючи їх, коли вони не потрібні.
• Ясність коду: анотації життячасів явно показують, як дані пов'язані між собою, що робить код більш зрозумілим.
• Висока продуктивність: Lifetimes працюють на етапі компіляції та не впливають на продуктивність програми під час виконання.

```rust
fn longest<'a>(s1: &'a str, s2: &'a str) -> &'a str {
    if s1.len() > s2.len() {
        s1
    } else {
        s2
    }
}

fn main() {
    let str1 = String::from("hello");
    let str2="world";

    let result = longest(&str1, &str2);
    println!("Найдовший рядок: {}", result);
}
```

## What is an iterator?

Ітератор – це об'єкт, який дозволяє перебрати елементи колекції (наприклад, масиву, списку чи множини) по одному за раз. У Rust ітератор це структура, яка реалізує
Iterator trait.

## Основні методи ітератора в Rust:
next(): повертає наступний елемент ітерації або None, якщо елементи закінчились.
методи адаптерів: Функції на кшталт map, filter, take, які перетворюють чи фільтрують елементи ітерації.


```rust
let numbers = vec! [1, 2, 3, 4];
let mut iter = numbers.iter(); // Створюємо ітератор
while let Some(number) = iter.next() {
    println!("Кількість: {}", number);
}
```

## What is a collection?

Колекція це структура даних, яка зберігає набір елементів. Приклади колекцій:
• Vec<T>: вектор (динамічний масив).
• HashMap <K, V>: Хеш-таблиця.
• HashSet<T>: Безліч.
Колекції підтримують операції, такі як додавання, видалення та доступ до елементів.

```rust
let mut vec = Vec:: new(); // Створюємо порожній вектор
vec.push(1);              // Додаємо елемент
vec.push(2);
println!("{:?}", vec);    // [1, 2]
```

## How do they differ?

Ітератор:
• Це механізм обходу елементів.
• Не можна безпосередньо додавати або видаляти елементи.
• Ітератори "виснажуються" після використання.
• Приклади: .iter(), into_iter().

Колекція:
• Це контейнер для зберігання елементів.
• Підтримує операції зміни даних.
• Колекція залишається доступною.
• Приклади: Vec, HashMap, HashSet.

Приклад зв'язки колекції та ітератора:

```rust
let numbers = vec! [1, 2, 3, 4];
let doubled: Vec<_> = numbers.iter()
                             .map(|x| x * 2) // Застосовуємо до кожного елементу
                             .collect();     // Збираємо назад у вектор
println!("{:?}", doubled); // [2, 4, 6, 8]
```

## How are they used?

Ітератори:
• Для обходу елементів колекції.
• Для функціонального програмування (через адаптери: map, filter, fold).
• Для лінивої обробки даних.

```rust
let sum: i32 = vec![1, 2, 3].iter().sum(); // Сума всіх елементів
println!("Сума: {}", sum);
```

Колекції:
• Для зберігання та управління даними.
• Для забезпечення швидкого пошуку (наприклад у HashMap).
• Для організації даних у структурі.

```rust
let mut map = std::collections::HashMap::new();
map.insert("apple", 3);
map.insert("banana", 5);

if let Some(quantity) = map.get("apple") {
    println!("Яблука: {}", quantity);
}
```

## Як їх поєднувати?

Ітератори та колекції працюють разом, щоб забезпечити зручне управління та обробку даних. Ітератори отримують елементи з колекцій, а методи ітераторів дозволяють легко
змінювати, фільтрувати або агрегувати дані.

## What are macros?

Макроси це механізм для генерації коду на етапі компіляції. Вони дозволяють:
• Уникати повторення коду.
• Автоматизувати створення складних шаблонів.
• Спрощувати роботу з конструкціями, що повторюються.
• Макроси виконуються під час компіляції, що робить їх потужним інструментом для оптимізації та спрощення коду.

## Which problems do they solve?

• Усунення коду, що повторюється: Замість копіювання однакового коду можна визначити макрос, який буде генерувати потрібні конструкції.
• Генерація коду: Макроси дозволяють створювати складні структури чи функції на основі вхідних даних.
• Спрощення роботи з шаблонами: Макроси можуть приймати параметри та адаптувати код залежно від них.
• Підвищення продуктивності: Код, згенерований макросами, оптимізується на етапі компіляції, крім накладних витрат під час виконання.

## What is the difference between declarative and procedural macro?

Декларативні макроси створюються за допомогою macro_rules і працюють на основі зіставлення з шаблонами.

```rust
macro_rules! calculate {
    ($a:expr + $b:expr) => { $a + $b };
    ($a:expr * $b:expr) => { $a * $b };
}

fn main() {
    println!("{}", calculate!(2 + 3)); // 5
    println!("{}", calculate!(4 * 5)); // 20
}
```

Процедурні макроси дають більше контролю та гнучкості. Вони працюють з абстрактним синтаксичним деревом (AST) та вимагають окремої бібліотеки з підключенням proc_macro.

## Типи процедурних макросів:
Function-like: Використовуються як звичайні функції (custom_macro!(...)).
Derive: Автоматично реалізують трейти (#[derive(Debug)]).
Attribute-like: Змінюють або додають поведінку через атрибути (#[test]).

Приклад (Derive Macro):

```rust
use proc_macro::TokenStream;
#[proc_macro_derive(CustomDebug)]
pub fn custom_debug_derive(input: TokenStream) -> TokenStream {
    let _ = input;
    "impl std::fmt::Debug for MyStruct {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            write!(f, \"MyStruct Debug Output\")
        }
    }".parse().unwrap()
}
```

Застосування:


```rust
#[derive(CustomDebug)]
struct MyStruct;

fn main() {
    let my_struct = MyStruct;
    println!("{:?}", my_struct); // Висновок: MyStruct Debug Output
}
```

## Різниця між декларативними та процедурними макросами

Декларативні макроси:
• Використовують macro_rules!
• Підходять для простого шаблонного коду.
• Легко читати та писати.
• Менше можливостей для адаптації.

Процедурні макроси
• Застосовують бібліотеку ргоoc_macro.
• Можуть працювати з AST та складною логікою.
• Вимагають більше знань та зусиль.
• Максимальна гнучкість.

## Коли використати?

Декларативні макроси: Якщо потрібно просто замінити шаблон на код.
Процедурні макроси: Якщо потрібна складна обробка коду або автоматична генерація трейтів.

## How code is tested in Rust? Where should you put tests and why?

• Модульні тести (Unit Tests)

Що це:
Тестують окремі функції чи модулі в ізоляції. Вони перевіряють, чи правильно працює невелика частина коду.

Де розміщувати:
Модульні тести зазвичай пишуться у спеціальному модулі #[cfg(test)] у тому файлі, де знаходиться тестований код.

Чому так робити:
Тести залишаються поруч із кодом, що спрощує їх оновлення при зміні функціоналу. Їх зручно запускати разом із основним складанням.

```rust
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*; // імпортуємо функцію, що тестується

    #[test]
    fn test_add() {
        assert_eq!(add(2, 3), 5);
        assert_eq!(add(-1, 1), 0); // успішний тест
    }
}
```

• Інтеграційні тести (Integration Tests)

Що це:
Перевіряють взаємодію між різними модулями чи весь функціонал програми.

Де розміщувати:
Інтеграційні тести зберігаються у папці tests у корені проекту.

Чому так робити:
Логічно відокремлені від вихідного коду. Перевіряють додаток за умов, максимально близьких до реальних.

```rust
use my_crate::add;
#[test]
fn test_add_integration() {
    assert_eq!(add(10, 20), 30);
}
```

• Документальні тести (Doc Tests)

Що це:
Тести пишуться у коментарях документації (у потрійних слешах ///). Вони виконуються, щоб перевірити, що приклади документації працюють правильно.

Де розміщувати:
У коментарях до функцій, структур тощо.

Чому так робити:
Переконатися, що приклади документації залишаються актуальними. Поліпшити якість документації для користувачів.

```rust
/// Повертає суму двох чисел
////
/// # Приклад
/// ```
/// let result = my_crate:: add (2, 2);
/// assert_eq! (result, 4);
/// ```
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}
```

## Чому важливо правильно розміщувати тести?

• Логічна організація: модульні тести знаходяться поруч із кодом, що робить їх легко доступними для редагування. Інтеграційні тести відокремлені, щоб не засмічувати 
основні модулі.
• Зручність запуску: Rust автоматично визначає тести, їх тип та запускає їх при виклику cargo test.
• Читання: поділ тестів покращує розуміння структури проекту.

## Is Rust an OOP language?

Rust не є класичною об'єктно-орієнтованою мовою у тому сенсі, як, наприклад, C++ чи Java. Однак, Rust підтримує об'єктно-орієнтовані концепції через:
• Структури (structs), які можна використовувати уявлення об'єктів.
• Трейти, які грають роль інтерфейсів і дозволяють реалізовувати поліморфізм та абстракцію.

Але на відміну від класичних ООП-мов, Rust не підтримує успадкування (класи не можуть успадковувати один одного). Замість цього використовується композиція та трейти для
організації коду.

## Is it possible to use SOLID/GRASP?

Так, теоретично, можна використовувати SOLID і GRASP у Rust, проте це буде не зовсім те саме, що в класичних ООП-мовах.

• SOLID: Ці принципи (наприклад, єдина відповідальність, відкритість/закритість) цілком застосовні, але часто вони реалізуються через використання структур та трейтів
замість класів та успадкування.
• GRASP: Ці принципи також можна застосувати, наприклад, при проектуванні структур і створенні трейтів для реалізації залежностей та відповідальності.

У Rust замість успадкування частіше використовується композиція та трейти для досягнення гнучкості та повторного використання коду.

## Does it have inheritance?

Ні, Rust не підтримує успадкування як у класичному ООП. У Rust спадкування класів не існує. Натомість Rust використовує трейти та композицію.
Трейти дозволяють визначати загальні інтерфейси, які можуть реалізовувати різні структури. Це дає можливість використовувати поліморфізм, але без наслідування.

Приклад використання трейту:

```rust
trait Speak {
    fn speak(&self);
}

struct Dog;
struct Cat;

impl Speak for Dog {
    fn speak(&self) {
        println!("Woof!");
    }
}

impl Speak for Cat {
    fn speak(&self) {
        println!("Meow!");
    }
}

fn make_sound(speaker: &dyn Speak) {
    speaker.speak();
}
```

## Is Rust a functional language?

Так, Rust має функціональні особливості. Хоча це не чисто функціональна мова, в Rust можна використовувати багато концепцій функціонального програмування:
• Безмутабельність за промовчанням.
• Функції, як об'єкти першого класу.
• Замикання (closures).
• Опціональні та результатні типи (Option, Result) для обробки помилок без винятків.
• Високорівневі абстракції за допомогою ітераторів та колекцій.

## What variance rules does Rust have?

У Rust є кілька важливих правил варіації, які стосуються роботи з типами, особливо в контексті посилань та володіння:

• Covariant: Коли тип має параметр, який є covariant, то це означає, що якщо тип T є підтипом типу U, то &T буде підтипом &U Прикладом є посилання на об'єкт:

```rust
fn example(x: &str) {
    let y: & String = x; // це працює, оскільки &str є підтипом &String
}
```

• Contravariant: Протилежність до коваріантності, де типи в параметрі функції змінюються на протилежні.
• Invariant: Якщо тип не змінюється, як це відбувається з типами володіння, наприклад, з String, де володіння точно визначає, хто може змінювати дані.

Rust ретельно керує типами через систему володіння та запозичень, забезпечуючи сувору безпеку типів, що також впливає на те, як ці правила працюють.